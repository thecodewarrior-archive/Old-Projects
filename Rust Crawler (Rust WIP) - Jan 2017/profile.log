FUNCTION  syntastic#log#debug()
Called 14 times
Total time:   0.000268
 Self time:   0.000182

count  total (s)   self (s)
   14   0.000230   0.000144     if !s:_isDebugEnabled(a:level)
   14              0.000027         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>49_BufEnterHook()
Called 2 times
Total time:   0.003629
 Self time:   0.000261

count  total (s)   self (s)
    2   0.000277   0.000029     let buf = syntastic#util#fname2buf(a:fname)
    2   0.000100   0.000049     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    2              0.000016     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    2              0.000019         let idx = index(reverse(copy(s:_check_stack)), buf)
    2              0.000004         if idx >= 0
                                        if !has('vim_starting')
                                            call remove(s:_check_stack, -idx - 1)
                                            call s:UpdateErrors(buf, 1, [])
                                        endif
                                    elseif &buftype ==# ''
    2   0.003104   0.000035             call s:notifiers.refresh(g:SyntasticLoclist.current())
    2              0.000002         endif
    2              0.000003     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"]')
                                    let owner = str2nr(getbufvar(buf, 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif

FUNCTION  <SNR>76_OnCursorHold()
Called 1 time
Total time:   0.000617
 Self time:   0.000042

count  total (s)   self (s)
    1   0.000101   0.000012   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1   0.000057   0.000014   call s:SetUpCompleteopt()
    1   0.000452   0.000009   call s:OnFileReadyToParse()

FUNCTION  <SNR>49_BufWinEnterHook()
Called 2 times
Total time:   0.000497
 Self time:   0.000194

count  total (s)   self (s)
    2   0.000290   0.000026     let buf = syntastic#util#fname2buf(a:fname)
    2   0.000087   0.000048     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWinEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    2              0.000016     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    2              0.000063         let idx = index(reverse(copy(s:_check_stack)), buf)
    2              0.000010         if idx >= 0 && !has('vim_starting')
                                        call remove(s:_check_stack, -idx - 1)
                                        call s:UpdateErrors(buf, 1, [])
                                    endif
    2              0.000002     endif

FUNCTION  indent_guides#disable()
Called 2 times
Total time:   0.000141
 Self time:   0.000040

count  total (s)   self (s)
    2              0.000009   let g:indent_guides_autocmds_enabled = 0
    2   0.000130   0.000029   call indent_guides#clear_matches()

FUNCTION  301()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000012     for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
                                endfor

FUNCTION  303()
Called 2 times
Total time:   0.000112
 Self time:   0.000088

count  total (s)   self (s)
    2              0.000012     let buf = a:0 ? a:1 : bufnr('')
    2   0.000058   0.000034     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
    2              0.000017     if type(loclist) != type({}) || empty(loclist)
                                    unlet! loclist
                                    let loclist = g:SyntasticLoclist.New([])
                                endif
    2              0.000004     return loclist

FUNCTION  306()
Called 10 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
   10              0.000048     return empty(self._rawLoclist)

FUNCTION  307()
Called 2 times
Total time:   0.000184
 Self time:   0.000053

count  total (s)   self (s)
    2              0.000012     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
    2   0.000159   0.000028     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  308()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000009     return copy(self._rawLoclist)

FUNCTION  syntastic#util#stamp()
Called 2 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    2              0.000062     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  nerdtree#checkForBrowse()
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000022     if !isdirectory(a:dir)
    2              0.000004         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  358()
Called 4 times
Total time:   0.000172
 Self time:   0.000056

count  total (s)   self (s)
    4   0.000166   0.000050     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  359()
Called 2 times
Total time:   0.000470
 Self time:   0.000119

count  total (s)   self (s)
    2   0.000058   0.000020     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
    2   0.000050   0.000020     let old_signs = copy(self._bufSignIds())
    2   0.000082   0.000010     if self.enabled()
    2              0.000005         if !s:setup_done
                                        call self._setup()
                                        let s:setup_done = 1
                                        lockvar s:setup_done
                                    endif
                            
    2   0.000178   0.000018         call self._signErrors(a:loclist)
    2              0.000003     endif
    2   0.000069   0.000018     call self._removeSigns(old_signs)

FUNCTION  361()
Called 2 times
Total time:   0.000160
 Self time:   0.000149

count  total (s)   self (s)
    2              0.000009     let loclist = a:loclist
    2   0.000023   0.000012     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  362()
Called 2 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000012     if has('signs')
    2              0.000013         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
    2              0.000002     endif

FUNCTION  363()
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000012     if !exists('b:syntastic_private_sign_ids')
                                    let b:syntastic_private_sign_ids = []
                                endif
    2              0.000004     return b:syntastic_private_sign_ids

FUNCTION  <SNR>74__isDebugEnabled_smart()
Called 14 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
   14              0.000078     return and(g:syntastic_debug, a:level)

FUNCTION  syntastic#util#getbufvar()
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000021     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  <SNR>76_AllowedToCompleteInCurrentBuffer()
Called 795 times
Total time:   0.073839
 Self time:   0.010382

count  total (s)   self (s)
  795   0.073033   0.009576   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  syntastic#util#var()
Called 14 times
Total time:   0.000352
 Self time:   0.000205

count  total (s)   self (s)
   14   0.000342   0.000195     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  syntastic#util#compareLexi()
Called 2 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
    4              0.000030     for idx in range(max([len(a:a), len(a:b)]))
    4              0.000029         let a_element = str2nr(get(a:a, idx, 0))
    4              0.000026         let b_element = str2nr(get(a:b, idx, 0))
    4              0.000012         if a_element != b_element
    2              0.000006             return a_element > b_element ? 1 : -1
                                    endif
    2              0.000008     endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  <SNR>17_record()
Called 4 times
Total time:   0.001031
 Self time:   0.000226

count  total (s)   self (s)
    4              0.000029 	if s:locked | retu | en
    4              0.000021 	let bufnr = a:bufnr + 0
    4              0.000027 	let bufname = bufname(bufnr)
    4              0.000021 	if bufnr > 0 && !empty(bufname)
    4              0.000041 		cal filter(s:mrbs, 'v:val != bufnr')
    4              0.000018 		cal insert(s:mrbs, bufnr)
    4   0.000856   0.000051 		cal s:addtomrufs(bufname)
    4              0.000004 	en

FUNCTION  <SNR>66_Setup()
Called 2 times
Total time:   0.000178
 Self time:   0.000157

count  total (s)   self (s)
    2              0.000015     if index(g:indentLine_fileTypeExclude, &filetype) isnot -1
                                    return
                                endif
                            
    2              0.000014     if len(g:indentLine_fileType) isnot 0 && index(g:indentLine_fileType, &filetype) is -1
                                    return
                                endif
                            
    2              0.000008     for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) is bufname('')
                                        return
                                    endif
                                endfor
                            
    2              0.000005     if &filetype ==# ""
                                    call s:InitColor()
                                endif
                            
    2              0.000005     if g:indentLine_enabled
    2   0.000050   0.000029         call s:IndentLinesEnable()
    2              0.000004     endif
                            
    2              0.000005     if g:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
                                endif

FUNCTION  <SNR>58_Highlight_Matching_Pair()
Called 794 times
Total time:   0.915724
 Self time:   0.915724

count  total (s)   self (s)
                              " Remove any previous match.
  794              0.011842   if exists('w:paren_hl_on') && w:paren_hl_on
   48              0.000385     silent! call matchdelete(3)
   48              0.000249     let w:paren_hl_on = 0
   48              0.000105   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  794              0.008148   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  794              0.005790   let c_lnum = line('.')
  794              0.014091   let c_col = col('.')
  794              0.002174   let before = 0
                            
  794              0.005868   let text = getline(c_lnum)
  794              0.029007   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  794              0.003708   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  794              0.008784     let [c_before, c] = matches[1:2]
  794              0.001448   endif
  794              0.025631   let plist = split(&matchpairs, '.\zs[:,]')
  794              0.006111   let i = index(plist, c)
  794              0.002316   if i < 0
                                " not found, in Insert mode try character before the cursor
  714              0.004508     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
  714              0.001372     if i < 0
                                  " not found, nothing to do
  714              0.001725       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
   80              0.000175   if i % 2 == 0
    3              0.000009     let s_flags = 'nW'
    3              0.000018     let c2 = plist[i + 1]
    3              0.000006   else
   77              0.000221     let s_flags = 'nbW'
   77              0.000211     let c2 = c
   77              0.000464     let c = plist[i - 1]
   77              0.000135   endif
   80              0.000250   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   80              0.000169   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
   80              0.000575   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
   80              0.024604   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
   80              0.001419   let stoplinebottom = line('w$')
   80              0.000423   let stoplinetop = line('w0')
   80              0.000208   if i % 2 == 0
    3              0.000014     let stopline = stoplinebottom
    3              0.000005   else
   77              0.000341     let stopline = stoplinetop
   77              0.000106   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   80              0.000495   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
   80              0.000649     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   80              0.000120   endif
   80              0.000169   try
   80              0.691452     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
   80              0.000484   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
   80              0.000190   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
   80              0.000313   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   48              0.000262     if exists('*matchaddpos')
   48              0.001513       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
   48              0.000091     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
   48              0.000157     let w:paren_hl_on = 1
   48              0.000063   endif

FUNCTION  syntastic#util#bufIsActive()
Called 2 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
    2              0.000015     let buf = str2nr(a:buffer)
                            
    2              0.000014     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
    2              0.000016     for tab in range(1, tabpagenr('$'))
    2              0.000013         if index(tabpagebuflist(tab), buf) >= 0
    2              0.000004             return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  <SNR>76_OnBufferEnter()
Called 2 times
Total time:   0.007870
 Self time:   0.004247

count  total (s)   self (s)
    2   0.000226   0.000031   if !s:VisitedBufferRequiresReparse()
                                return
                              endif
                            
    2              0.004163   exec s:python_command "ycm_state.OnBufferVisit()"
    2   0.003469   0.000041   call s:OnFileReadyToParse()

FUNCTION  indent_guides#init_matches()
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000019   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []

FUNCTION  <SNR>76_SetUpCompleteopt()
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                              " Some plugins (I'm looking at you, vim-notes) change completeopt by for
                              " instance adding 'longest'. This breaks YCM. So we force our settings.
                              " There's no two ways about this: if you want to use YCM then you have to
                              " have these completeopt settings, otherwise YCM won't work at all.
                            
                              " We need menuone in completeopt, otherwise when there's only one candidate
                              " for completion, the menu doesn't show up.
    1              0.000015   set completeopt-=menu
    1              0.000005   set completeopt+=menuone
                            
                              " This is unnecessary with our features. People use this option to insert
                              " the common prefix of all the matches and then add more differentiating chars
                              " so that they can select a more specific match. With our features, they
                              " don't need to insert the prefix; they just type the differentiating chars.
                              " Also, having this option set breaks the plugin.
    1              0.000005   set completeopt-=longest
                            
    1              0.000004   if g:ycm_add_preview_to_completeopt
                                set completeopt+=preview
                              endif

FUNCTION  <SNR>66_IndentLinesEnable()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000017     if exists("b:indentLine_enabled") && b:indentLine_enabled
    2              0.000004         return
                                else
                                    let b:indentLine_enabled = 1
                                endif
                                call s:SetConcealOption()
                            
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                            
                                let space = &l:shiftwidth is 0 ? &l:tabstop : &l:shiftwidth
                            
                                if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
                                if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
                                    let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                    endfor
                                endif

FUNCTION  <SNR>76_VisitedBufferRequiresReparse()
Called 2 times
Total time:   0.000195
 Self time:   0.000057

count  total (s)   self (s)
    2   0.000155   0.000017   if !s:AllowedToCompleteInCurrentBuffer()
                                return 0
                              endif
                            
    2              0.000010   if bufnr( '' ) ==# s:previous_allowed_buffer_number
                                return 0
                              endif
    2              0.000011   let s:previous_allowed_buffer_number = bufnr( '' )
    2              0.000003   return 1

FUNCTION  <SNR>17_addtomrufs()
Called 4 times
Total time:   0.000805
 Self time:   0.000805

count  total (s)   self (s)
    4              0.000166 	let fn = fnamemodify(a:fname, ':p')
    4              0.000048 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    4              0.000416 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
    4              0.000043 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    4              0.000008 	if idx
    2              0.000028 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
    2              0.000009 		cal insert(s:mrufs, fn)
    2              0.000010 		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
    2              0.000002 	en

FUNCTION  <SNR>76_SetUpYcmChangedTick()
Called 795 times
Total time:   0.010773
 Self time:   0.010773

count  total (s)   self (s)
  795              0.009867   let b:ycm_changedtick  = get( b:, 'ycm_changedtick', {   'file_ready_to_parse' : -1, } )

FUNCTION  syntastic#util#fname2buf()
Called 4 times
Total time:   0.000512
 Self time:   0.000512

count  total (s)   self (s)
    4              0.000023     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
                                endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
    4              0.000025     for md in [':~:.', ':~', ':p']
    4              0.000290         let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
    4              0.000014         if buf != -1
    4              0.000008             break
                                    endif
                                endfor
    4              0.000008     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
                                    let buf = bufnr(fnamemodify(a:fname, ':p'))
                                endif
                            
    4              0.000018     if exists('+shellslash')
                                    let &shellslash = old_shellslash
                                endif
                            
    4              0.000008     return buf

FUNCTION  syntastic#util#rawVar()
Called 14 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
   14              0.000135     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  indent_guides#clear_matches()
Called 2 times
Total time:   0.000101
 Self time:   0.000079

count  total (s)   self (s)
    2   0.000041   0.000019   call indent_guides#init_matches()
    2              0.000009   if !empty(w:indent_guides_matches)
                                let l:index = 0
                                for l:match_id in w:indent_guides_matches
                                  try
                                    call matchdelete(l:match_id)
                                  catch /E803:/
                                    " Do nothing
                                  endtry
                                  call remove(w:indent_guides_matches, l:index)
                                  let l:index += l:index
                                endfor
                              endif

FUNCTION  <SNR>76_AllowedToCompleteInBuffer()
Called 795 times
Total time:   0.063457
 Self time:   0.063457

count  total (s)   self (s)
  795              0.015630   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
  795              0.014633   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
                                return 0
                              endif
                            
  795              0.004176   if exists( 'b:ycm_largefile' )
                                return 0
                              endif
                            
  795              0.008901   let whitelist_allows = has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
  795              0.006744   let blacklist_allows = !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
  795              0.003105   return whitelist_allows && blacklist_allows

FUNCTION  340()
Called 2 times
Total time:   0.002957
 Self time:   0.001010

count  total (s)   self (s)
    2   0.000145   0.000051     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    2   0.000056   0.000018     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
   12              0.000032     for type in self._enabled_types
   10              0.000173         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   10   0.000400   0.000145         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
    8              0.000046             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    2              0.000016                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
    2   0.000229   0.000034                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    2   0.000491   0.000021                     call self._notifier[type].refresh(a:loclist)
    2   0.000102   0.000038                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    2              0.000005                 endif
    2              0.000002             else
    6   0.000897   0.000066                 call self._notifier[type].refresh(a:loclist)
    6              0.000008             endif
    8              0.000008         endif
   10              0.000012     endfor

FUNCTION  266()
Called 2 times
Total time:   0.000347
 Self time:   0.000041

count  total (s)   self (s)
    2   0.000052   0.000020     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    2   0.000293   0.000019     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  267()
Called 2 times
Total time:   0.000274
 Self time:   0.000178

count  total (s)   self (s)
    2   0.000055   0.000017     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    2   0.000070   0.000023     let auto_loc_list = syntastic#util#var('auto_loc_list')
    2   0.000024   0.000013     if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
                                else
    2              0.000018         if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
                                        try
                                            " Vim 7.4.2200 or later
                                            let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
                                        endtry
                            
                                        if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
                                            call SyntasticLoclistHide()
                            
                                            try
                                                " Vim 7.4.2200 or later
                                                call setloclist(0, [], 'r', { 'title': '' })
                                            catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
                                            endtry
                                            let w:syntastic_loclist_set = []
                                        endif
                                    endif
    2              0.000002     endif

FUNCTION  269()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000018     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  <SNR>76_OnFileReadyToParse()
Called 795 times
Total time:   0.412940
 Self time:   0.402167

count  total (s)   self (s)
                              " We need to call this just in case there is no b:ycm_changetick; this can
                              " happen for special buffers.
  795   0.021159   0.010386   call s:SetUpYcmChangedTick()
                            
                              " Order is important here; we need to extract any information before
                              " reparsing the file again. If we sent the new parse request first, then
                              " the response would always be pending when we called
                              " HandleFileParseRequest.
  795              0.365776   exec s:python_command "ycm_state.HandleFileParseRequest()"
                            
  795              0.006870   let buffer_changed = b:changedtick != b:ycm_changedtick.file_ready_to_parse
  795              0.002257   if buffer_changed
    2              0.002562     exec s:python_command "ycm_state.OnFileReadyToParse()"
    2              0.000007   endif
  795              0.003336   let b:ycm_changedtick.file_ready_to_parse = b:changedtick

FUNCTION  indent_guides#process_autocmds()
Called 2 times
Total time:   0.000186
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000009   if g:indent_guides_autocmds_enabled
                                call indent_guides#enable()
                              else
    2   0.000163   0.000022     call indent_guides#disable()
    2              0.000002   end

FUNCTION  293()
Called 4 times
Total time:   0.000126
 Self time:   0.000032

count  total (s)   self (s)
    4   0.000123   0.000029     return syntastic#util#var('echo_current_error')

FUNCTION  294()
Called 2 times
Total time:   0.000137
 Self time:   0.000064

count  total (s)   self (s)
    2   0.000094   0.000021     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  297()
Called 4 times
Total time:   0.000138
 Self time:   0.000043

count  total (s)   self (s)
    4   0.000136   0.000041     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  298()
Called 2 times
Total time:   0.000347
 Self time:   0.000198

count  total (s)   self (s)
    2   0.000083   0.000014     if self.enabled()
    2   0.000052   0.000020         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    2   0.000051   0.000015         call self._reset()
    2              0.000010         let buf = bufnr('')
    2   0.000037   0.000025         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    2              0.000006         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
    2              0.000003     endif

FUNCTION  AutoPairsTryInit()
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000014   if exists('b:autopairs_loaded')
    2              0.000005     return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
                              if g:AutoPairsMapCR
                                if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
                                  let info = maparg('<CR>', 'i', 0, 1)
                                  if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
                                  endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
                                if old_cr !~ 'AutoPairsReturn'
                                  if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
                                  execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
                                end
                              endif
                              call AutoPairsInit()

FUNCTION  <SNR>76_OnCursorMovedNormalMode()
Called 792 times
Total time:   0.572602
 Self time:   0.089921

count  total (s)   self (s)
  792   0.080499   0.006887   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  792   0.419502   0.010433   call s:OnFileReadyToParse()
  792              0.067422   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  794   0.915724             <SNR>58_Highlight_Matching_Pair()
  792   0.572602   0.089921  <SNR>76_OnCursorMovedNormalMode()
  795   0.412940   0.402167  <SNR>76_OnFileReadyToParse()
  795   0.073839   0.010382  <SNR>76_AllowedToCompleteInCurrentBuffer()
  795   0.063457             <SNR>76_AllowedToCompleteInBuffer()
  795   0.010773             <SNR>76_SetUpYcmChangedTick()
    2   0.007870   0.004247  <SNR>76_OnBufferEnter()
    2   0.003629   0.000261  <SNR>49_BufEnterHook()
    2   0.002957   0.001010  340()
    4   0.001031   0.000226  <SNR>17_record()
    4   0.000805             <SNR>17_addtomrufs()
    1   0.000617   0.000042  <SNR>76_OnCursorHold()
    4   0.000512             syntastic#util#fname2buf()
    2   0.000497   0.000194  <SNR>49_BufWinEnterHook()
    2   0.000470   0.000119  359()
   14   0.000352   0.000205  syntastic#util#var()
    2   0.000347   0.000198  298()
    2   0.000347   0.000041  266()
    2   0.000274   0.000178  267()
   14   0.000268   0.000182  syntastic#log#debug()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  794              0.915724  <SNR>58_Highlight_Matching_Pair()
  795   0.412940   0.402167  <SNR>76_OnFileReadyToParse()
  792   0.572602   0.089921  <SNR>76_OnCursorMovedNormalMode()
  795              0.063457  <SNR>76_AllowedToCompleteInBuffer()
  795              0.010773  <SNR>76_SetUpYcmChangedTick()
  795   0.073839   0.010382  <SNR>76_AllowedToCompleteInCurrentBuffer()
    2   0.007870   0.004247  <SNR>76_OnBufferEnter()
    2   0.002957   0.001010  340()
    4              0.000805  <SNR>17_addtomrufs()
    4              0.000512  syntastic#util#fname2buf()
    2   0.003629   0.000261  <SNR>49_BufEnterHook()
    4   0.001031   0.000226  <SNR>17_record()
   14   0.000352   0.000205  syntastic#util#var()
    2   0.000347   0.000198  298()
    2   0.000497   0.000194  <SNR>49_BufWinEnterHook()
   14   0.000268   0.000182  syntastic#log#debug()
    2   0.000274   0.000178  267()
    2   0.000178   0.000157  <SNR>66_Setup()
    2   0.000160   0.000149  361()
   14              0.000147  syntastic#util#rawVar()

